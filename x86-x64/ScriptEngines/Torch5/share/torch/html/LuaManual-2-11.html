<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>

  Coroutines
</title>
<link href="doctorch.css" rel="stylesheet" type="text/css">
</head>

<body class="torchdoc">
<div id="container">

<div id="header">
<h3>
  Coroutines</h3>
</div>

<div id="navline">
<a href="index.html">Torch Manual</a>&nbsp; > &nbsp; <a href="LuaManual.html">
Lua 5.1 Reference Manual</a>&nbsp; > &nbsp; <a href="LuaManual-2.html">
  The Language</a>&nbsp; > &nbsp; <b>
  Coroutines</b>
</div>

<div id="contents">
<a name="Coroutines"></a>

<p>

<p>

<p>

 Lua supports coroutines, also called <i>collaborative multithreading</i>. A coroutine in Lua represents an independent thread of execution. Unlike threads in multithread systems, however, a coroutine only suspends its execution by explicitly calling a yield function.   
<p>

 You create a coroutine with a call to <a href="LuaManual-5-2-1.html#coroutinecreatef"><code>coroutine.create (f)</code></a>. Its sole argument is a function that is the main function of the coroutine. The <code>create</code> function only creates a new coroutine and returns a handle to it (an object of type <i>thread</i>); it does not start the coroutine execution.   
<p>

 When you first call <a href="LuaManual-5-2-2.html#coroutineresumecoval"><code>coroutine.resume (co [, val1, ...])</code></a>, passing as its first argument the thread returned by <a href="LuaManual-5-2-1.html#coroutinecreatef"><code>coroutine.create (f)</code></a>, the coroutine starts its execution, at the first line of its main function. Extra arguments passed to <a href="LuaManual-5-2-2.html#coroutineresumecoval"><code>coroutine.resume (co [, val1, ...])</code></a> are passed on to the coroutine main function. After the coroutine starts running, it runs until it terminates or <i>yields</i>.   
<p>

 A coroutine can terminate its execution in two ways: normally, when its main function returns (explicitly or implicitly, after the last instruction); and abnormally, if there is an unprotected error. In the first case, <a href="LuaManual-5-2-2.html#coroutineresumecoval"><code>coroutine.resume (co [, val1, ...])</code></a> returns <b>true</b>, plus any values returned by the coroutine main function. In case of errors, <a href="LuaManual-5-2-2.html#coroutineresumecoval"><code>coroutine.resume (co [, val1, ...])</code></a> returns <b>false</b> plus an error message.   
<p>

 A coroutine yields by calling <a href="LuaManual-5-2-6.html#coroutineyield"><code>coroutine.yield (...)</code></a>. When a coroutine yields, the corresponding <a href="LuaManual-5-2-2.html#coroutineresumecoval"><code>coroutine.resume (co [, val1, ...])</code></a> returns immediately, even if the yield happens inside nested function calls (that is, not in the main function, but in a function directly or indirectly called by the main function). In the case of a yield, <a href="LuaManual-5-2-2.html#coroutineresumecoval"><code>coroutine.resume (co [, val1, ...])</code></a> also returns <b>true</b>, plus any values passed to <a href="LuaManual-5-2-6.html#coroutineyield"><code>coroutine.yield (...)</code></a>. The next time you resume the same coroutine, it continues its execution from the point where it yielded, with the call to <a href="LuaManual-5-2-6.html#coroutineyield"><code>coroutine.yield (...)</code></a> returning any extra arguments passed to <a href="LuaManual-5-2-2.html#coroutineresumecoval"><code>coroutine.resume (co [, val1, ...])</code></a>.   
<p>

 Like <a href="LuaManual-5-2-1.html#coroutinecreatef"><code>coroutine.create (f)</code></a>, the <a href="LuaManual-5-2-5.html#coroutinewrapf"><code>coroutine.wrap (f)</code></a> function also creates a coroutine, but instead of returning the coroutine itself, it returns a function that, when called, resumes the coroutine. Any arguments passed to this function go as extra arguments to <a href="LuaManual-5-2-2.html#coroutineresumecoval"><code>coroutine.resume (co [, val1, ...])</code></a>. <a href="LuaManual-5-2-5.html#coroutinewrapf"><code>coroutine.wrap (f)</code></a> returns all the values returned by <a href="LuaManual-5-2-2.html#coroutineresumecoval"><code>coroutine.resume (co [, val1, ...])</code></a>, except the first one (the boolean error code). Unlike <a href="LuaManual-5-2-2.html#coroutineresumecoval"><code>coroutine.resume (co [, val1, ...])</code></a>, <a href="LuaManual-5-2-5.html#coroutinewrapf"><code>coroutine.wrap (f)</code></a> does not catch errors; any error is propagated to the caller.   
<p>

 As an example, consider the following code:
<pre>
     function foo (a)
       print("foo", a)
       return coroutine.yield(2*a)
     end
     
     co = coroutine.create(function (a,b)
           print("co-body", a, b)
           local r = foo(a+1)
           print("co-body", r)
           local r, s = coroutine.yield(a+b, a-b)
           print("co-body", r, s)
           return b, "end"
     end)
            
     print("main", coroutine.resume(co, 1, 10))
     print("main", coroutine.resume(co, "r"))
     print("main", coroutine.resume(co, "x", "y"))
     print("main", coroutine.resume(co, "x", "y"))
</pre>
<p>

<p>

 When you run it, it produces the following output:
<pre>
     co-body 1       10
     foo     2
     
     main    true    4
     co-body r
     main    true    11      -9
     co-body x       y
     main    true    10      end
     main    false   cannot resume dead coroutine
</pre>
<p>

</div>



<div id="footer-left">&nbsp;<a href="LuaManual-2-10.html">
  Garbage Collection</a></div>
<div id="footer-right"><a href=""></a>&nbsp;</div>

<div id="last-modified">

</div>

</div>
</body>
</html>
