<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>

 require (modname)
</title>
<link href="doctorch.css" rel="stylesheet" type="text/css">
</head>

<body class="torchdoc">
<div id="container">

<div id="header">
<h3>
 require (modname)</h3>
</div>

<div id="navline">
<a href="index.html">Torch Manual</a>&nbsp; > &nbsp; <a href="LuaManual.html">
Lua 5.1 Reference Manual</a>&nbsp; > &nbsp; <a href="LuaManual-5.html">
  Standard Libraries</a>&nbsp; > &nbsp; <a href="LuaManual-5-3.html">
  Modules</a>&nbsp; > &nbsp; <b>
 <code>require (modname)</code></b>
</div>

<div id="contents">
<a name="requiremodname"></a>

<p>

<p>

<p>

 Loads the given module. The function starts by looking into the <a href="LuaManual-5-3-4.html#packageloaded"><code>package.loaded</code></a> table to determine whether <code>modname</code> is already loaded. If it is, then <code>require</code> returns the value stored at <code>package.loaded[modname]</code>. Otherwise, it tries to find a <i>loader</i> for the module.   
<p>

 To find a loader, first <code>require</code> queries <code>package.preload[modname]</code>. If it has a value, this value (which should be a function) is the loader. Otherwise <code>require</code> searches for a Lua loader using the path stored in <a href="LuaManual-5-3-6.html#packagepath"><code>package.path</code></a>. If that also fails, it searches for a C loader using the path stored in <a href="LuaManual-5-3-3.html#packagecpath"><code>package.cpath</code></a>. If that also fails, it tries an <i>all-in-one</i> loader (see below).   
<p>

 When loading a C library, <code>require</code> first uses a dynamic link facility to link the application with the library. Then it tries to find a C function inside this library to be used as the loader. The name of this C function is the string "=luaopen_=" concatenated with a copy of the module name where each dot is replaced by an underscore. Moreover, if the module name has a hyphen, its prefix up to (and including) the first hyphen is removed. For instance, if the module name is <code>a.v1-b.c</code>, the function name will be <code>luaopen_b_c</code>.   
<p>

 If <code>require</code> finds neither a Lua library nor a C library for a module, it calls the <i>all-in-one loader</i>. This loader searches the C path for a library for the root name of the given module. For instance, when requiring <code>a.b.c</code>, it will search for a C library for <code>a</code>. If found, it looks into it for an open function for the submodule; in our example, that would be <code>luaopen_a_b_c</code>. With this facility, a package can pack several C submodules into one single library, with each submodule keeping its original open function.   
<p>

 Once a loader is found, <code>require</code> calls the loader with a single argument, <code>modname</code>. If the loader returns any value, <code>require</code> assigns the returned value to <code>package.loaded[modname]</code>. If the loader returns no value and has not assigned any value to <code>package.loaded[modname]</code>, then <code>require</code> assigns <b>true</b> to this entry. In any case, <code>require</code> returns the final value of <code>package.loaded[modname]</code>.   
<p>

 If there is any error loading or running the module, or if it cannot find any loader for the module, then <code>require</code> signals an error.      
<p>

<p>

<hr>
<p>

</div>



<div id="footer-left">&nbsp;<a href="LuaManual-5-3-1.html">
 <code>module (name [, ...])</code></a></div>
<div id="footer-right"><a href="LuaManual-5-3-3.html">
 <code>package.cpath</code></a>&nbsp;</div>

<div id="last-modified">

</div>

</div>
</body>
</html>
